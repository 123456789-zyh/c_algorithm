//算法思路（从小到大排序）：
//1、一组数据a[N]，按照一定的间隔gap划分组，同一个组内的数据间隔是gap的整数倍，一般增量gap的初始值为N/2
//2、对每组内的数据进行直接插入排序
//3、缩小组内间距，gap/=2
//4、再对每组数据进行直接插入排序
//5、重复3、4步骤，直到gap为1，原数据就已经是有序的了
#include<stdio.h>

int main(void)
{
    int a[] = {9,8,7,6,5,4,3} ;
    int n = sizeof(a) / sizeof(a[0]) ;
    int i, j, k, temp, gap;

    printf("原序列为：") ;
    for(i=0; i<n; ++i)
        printf("%d ",a[i]) ;

    /*希尔排序*/
    for(gap=n/2; gap>=1; gap/=2)//一般来说gap的初始值大小为n/2，每次划分组间距的时候都是以gap/=2来进行划分
		                       //，希尔排序是一种缩小增量的排序算法，先达到部分数据有序，然后再达到整体数据有序，
							   //这个过程是不断缩小gap的，直到gap为0停止
    {
        for(i=0; i<gap; ++i)//希尔排序是将一个数组按照一定的间距划分成若干个数组，再对这若干个数组进行直接插入排序
		                	//，所以第二层for循环控制的是数组的个数，也就是说对gap个数组进行直接插入排序
        
		{
            for(j=i+gap; j<n; j+=gap)//里面两个for循环是直接插入排序的算法，不同的是，在直接插入排序当中
				                     //，一组数据中的间距为 1 ，而在这里只是将 1 换成了gap（间距）
            {
                if(a[j-gap] > a[j])
                {
                    temp = a[j] ;
                    for(k=j-gap; k>=0 && a[k]>temp; k-=gap)
                        a[k+gap] = a[k] ;
                    a[k+gap] = temp ;
                }
            }
        }
    }

    printf("\n\n排后序列：") ;
    for(i=0; i<n; ++i)
        printf("%d ",a[i]) ;
    printf("\n") ;
    return 0 ;
}

